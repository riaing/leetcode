给一个矩阵, 找出所有从左上到右下path最小值中的最大值.
eg: 
{8,4,3,5}
{6,5,9,8}

所有的path:

8->4->3->5->8 min:3

8->4->3->9->8 min:3

8->4->5->9->8 min:5

8->6->5->9->8 min:5

Result = Math.max(3,3,5,5,) = 5
  
---------------- DP ------------------------------------------------------
DP[i][j]:到达i,j这个点时所有path最小值中的最大值

公式：到达某点时，其实只有两条path：从左后者上来。
if m[i][j] < dp[i-1][j] && dp[i][j-1], dp[i][j] = m[i][j] //到达m[i][j]时可以从左或者右来，
                                                                                //这时m[i][j]肯定分别是两条路径的最小值了，所以所有路径中的最小值（就是m[i][j])的最大值就是它本身
if m[i][j] > dp[i-1][j] && dp[i][j-1], dp[i][j] = max(dp[i-1][j], dp[i][j-1])  //到达m[i][j]时可以从左或者右来，因为m[i][j]已经比路径中的最小值都大了，它就失去了路径最小值的资格，所以两条包含m[i][j]
                                                           //的d的路径的最小值还是dp[i-1][j], dp[i][j-1], 两者取最大即是包含m[i][j]的所有路径最小值中最大的那一个
if dp[i][j-1] < m[i][j] < dp[i-1][j]或相反，dp[i][j] = m[i][j] // 如果m[i][j] 小于其中一个大于另一个，那它肯定还是两路径中的最小值，返回它本身
                                                             //eg: m[i][j] = 4; A路 5 - 6. B路 5 - 2. 到达m[i][j]后，A路变成 5-6-4，最小值更新为4. B路变成 5-2-4，最小值还是2
                                                             // 现在要在路径最小值中取大的那个，就是在A的4和B的2中中取max（4，2） = 4. 所以返回m[i][j]
初始化：
dp[0][0] = m[i][j] 
dp[0][j]= min{m[0][j], dp[0][j-1]} // 只有一条path，取path中的最小值即可
dp[i][0] = min{m[i][0], dp[i-1][0]} 

return dp[m][n]   
  
  


